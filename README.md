# Failover and Secure Cloud-IoT System Architecture

## Project Overview
This project involves the implementation of a secure IoT system leveraging ESP32 microcontrollers, AES encryption for MQTT messages, TEA and RC4 encryption for bluetooth communications, and AWS IoT services for MQTT messaging protocol, AWS Lambda for automatically triggering the decryption process of encrypted MQTT messages by accessing the AES decryption key stored in AWS Secrets Manager, AWS IAM for efficient role-based access control, AWS Timestream database for storing data, Grafana visualization platform for WebApp visualization of humidity and temperature.

## Objective
1. Develop a secure and functional IoT system using ESP32 microcontrollers.
2. Implement encrypted communication between devices and the cloud.
3. Implement fail-over mechanism by using ESP32 back-up over Bluetooth.
4. Implement encrypted bluetooth communication between ESP32 devices (main and back-up)
5. Utilize AWS IoT for MQTT messaging protocol.
6. Utilize AWS IAM for efficient role-based access control.
7. Utilize AWS Lambda for the decryption process of AES-encrypted MQTT messages.
8. Utilize AWS Secrets Manager for the cryptographic key storage in AWS cloud - storing AES key for decryption process of MQTT messages.
9. Utilize Timestream Database for efficient data storage and analysis.
10. Provide a user-friendly interface through a WebApp to visualize and monitor IoT data.
11. Emphasize security by integrating AES encryption and TEA for safe data transfer.


## Architecture
The architecture of this IoT project centers around the ESP32 microcontroller, which serves as the primary processing and communication hub. The ESP32 DevKit, with its built-in Wi-Fi and Bluetooth capabilities, enables seamless integration with sensors, actuators, and external servers. The microcontroller’s GPIO pins are utilized to interface with various components, including a DHT11 temperature and humidity sensor, LEDs, and a push button, all of which are mounted on a breadboard for a modular and organized layout.
A critical component of the system is the DHT11 sensor, which measures environmental parameters such as temperature and humidity. This sensor is connected to one of the ESP32’s GPIO pins, with a 5kΩ pull-up resistor to control the output voltage value. The ESP32 collects real-time data from the DHT11, processes it using MicroPython scripts, and transmits it to a cloud and displays it for monitoring purposes. This functionality demonstrates the system's ability to interact with and respond to its environment.
The architecture also includes two LEDs (red and white), which are connected to the ESP32 via GPIO pins through 230Ω resistors to regulate current flow. These LEDs provide visual feedback, such as indicating the system’s status such as normal and abnormal temperature and humidity in the surrounding environment. The push button offers user interaction capabilities, such as halting the operational state of the Main ESP32 microcontroller. The button is connected to a GPIO pin and ground through a pull-down resistor, to set the voltage level of GPIO to zero on button press (internal pull up sets it to high level when not pressed).
Power is supplied to the system via the ESP32’s USB connection, with 3.3V and GND lines distributed across the board to ensure all devices receive stable power. Signal wires are carefully routed and color-coded to simplify debugging and improve circuit clarity. For instance, purple wires connect the DHT11 sensor to the ESP32, while orange and green wires link the LEDs and the push button to their respective GPIO pins.
The functional flow begins with the ESP32 initializing the connected devices using MicroPython scripts developed in the Thonny IDE. The DHT11 sensor collects environmental data, which is then processed and transmitted over Wi-Fi using MQTT. The push button allows for manual intervention, triggering specific actions like making the main ESP32 Microcontroller unavailable, while the LEDs provide immediate feedback on the status of humidity and temperature. Secure communication protocols, implemented by integrating AES encryption, TEA and AWS IAM role-based authentication, ensure the integrity, confidentiality and safety of data transmission. 
This architecture demonstrates a practical and scalable IoT system, combining hardware and software seamlessly. By integrating the ESP32 with sensors, actuators, and secure communication protocols, the project provides a robust platform for understanding the principles of IoT.

## IoT System Architecture Diagram
The diagram below illustrates an Internet of Things (IoT) architecture that involves several components and technologies working together to provide a robust and secure IoT system. The key elements of this system include ESP32 microcontroller units, MQTT protocol for messaging, AWS IoT Core as a broker, AWS Timestream as a database, and a WebApp for user interaction.

![alt text](https://github.com/0x7a6b4c/Failover-and-Secure-Cloud-IoT-System-Architecture/blob/main/image/IoTSystemArchitecture.png)

The ESP32 microcontrollers, equipped with WiFi for MQTT and Bluetooth connectivity, are utilized to gather and process data from DHT11 temperature and humidity sensors. These microcontrollers are configured to interface with AWS IoT Core, using the MQTT protocol to publish the sensor data to the subscribed topic. To further enhance system reliability, a failover mechanism is implemented with a backup ESP32 microcontroller. This backup device is designed to automatically take over operations in the event of a failure of the primary ESP32 microcontroller. The system continuously monitors the status of the primary ESP32 every 10 seconds. If the primary unit becomes unresponsive for a total of 60 seconds, the backup device seamlessly assumes control. Once the primary ESP32 microcontroller becomes operational again, the system switches back to normal functionality. This failover mechanism significantly improves the overall system's reliability and ensures continuous availability of data processing and communication. Each ESP32 device implements AES encryption for encrypting the data sent to the AWS cloud over MQTT. AES (Advanced Encryption Standard) provides strong data encryption, ensuring that the information sent over the network is protected against eavesdropping and interception maintaining confidentiality.

### MQTT Protocol
MQTT (Message Queuing Telemetry Transport) is a lightweight, publish-subscribe network protocol that enables devices (clients) to communicate with a server (MQTT broker) across networks that may have low bandwidth or high latency. MQTT is particularly well-suited for IoT applications due to its efficient message delivery system and its ability to maintain stable connections with a minimal footprint.
In this system, MQTT facilitates the communication between the ESP32 devices and the AWS IoT Core. It handles message transmissions, where devices can publish data to topics that are subscribed to by the broker. This allows for real-time data exchange and immediate responsiveness in the IoT system.
### AWS IoT Core
AWS IoT Core serves as the MQTT broker in this architecture. It securely connects to the ESP32 devices, allowing for the reliable transfer of messages back and forth. AWS IoT Core supports various IoT protocols besides MQTT, but in this setup, MQTT is the chosen protocol due to its suitability for resource constraint environments.
The broker manages device connections, ensuring that each device is authenticated and authorized to communicate within the system. It also routes messages to the appropriate destination, like forwarding data to AWS Timestream or triggering actions based on received messages.
### AWS Lambda
AWS Lambda facilitates the decryption process for the AES-encrypted messages delivering from ESP32 to AWS IoT Core - MQTT topics. AWS Lambda is granted the role-based access control to access AWS Secrets Manager to retrieve the AES decryption key, to automatically trigger the decryption of MQTT messages and store it into AWS Timestream Database based upon the access permission policies set forth in the Lambda function.
### AWS Secrets Manager
AWS Secrets Manager helps us manage, retrieve, and rotate database credentials, application credentials, OAuth tokens, API keys, and other secrets throughout their life cycles. Secrets Manager improves the security posture, by helping us to avoid the need to hard-coded credentials in application source code. Storing the credentials in Secrets Manager helps avoid possible compromise by anyone who can inspect your application or the components. We replace hard-coded credentials with a runtime call of AWS Lambda to the Secrets Manager service to retrieve credentials(AES- decryption key) dynamically, and decrypt MQTT messages to store the data to AWS TimeStream database. This key was manually stored in the secret manager at the time of its configuration by the development team.
Moreover, with Secrets Manager, we can configure an automatic rotation schedule for our secrets. This enables you to replace long-term secrets with short-term ones, significantly reducing the risk of compromise. Since the credentials are no longer stored with the application, rotating credentials no longer requires updating your applications and deploying changes to application clients.
### AWS IAM (Identity and Access Management)
AWS Identity and Access Management (IAM) is a comprehensive service provided by Amazon Web Services (AWS) that enables us to manage access to AWS services and resources securely. IAM allows you to control who is authenticated (signed in) and authorized (has permissions) to use resources. With IAM, we can create and manage AWS users and groups, and use permissions to allow and deny their access to AWS resources.
In this project, IAM Role is evolved to assign the permissions to AWS Lambda by integrating permission policies in order to have sufficient privilege to access and read the key from AWS Secrets Manager for the decryption process, and the privilege to write into the created tables of AWS Timestream Database. A user with READ permissions for AWS Timestream Database is also created to give the Grafana sufficient permissions to retrieve the data from Timestream Database and visualize it.
### AWS Timestream Database
AWS Timestream is a managed time-series database designed specifically for fast ingestion, storage, and real-time querying of time-stamped data. It is ideal for IoT applications where vast volumes of data are collected over time.
Data from the ESP32 devices after being transmitted to AWS IoT Core, it will then be decrypted by Lambda function, and then pushed into AWS Timestream Database. This database stores the data efficiently and provides capabilities to analyze large time-series datasets, enabling insights and decision-making based on historical data trends.
### WebApp
The WebApp is provided by Grafana visualization platform, it provides a user-friendly interface to interact with the IoT system. We have connected it to both AWS IoT Core and AWS Timestream to retrieve and visualize data. Users can monitor the status of IoT devices, view real-time and historical data, and manage devices through the WebApp. This component is crucial for user engagement and operational oversight of the IoT system.
### Overall System Flow
In operation, AES encrypted MQTT messages containing humidity and temperature data flows from the ESP32 devices to AWS IoT Core via the MQTT protocol. After receiving the MQTT messages, AWS IoT rules will be triggered to deliver the data to predefined AWS Lambda. AWS Lambda will then retrieve the AES Key from AWS Secrets Manager, and decrypt the data to store the temperature and humidity to the AWS Timestream database, where it can be accessed and analyzed through the WebApp. This architecture not only ensures continuous data availability through the use of main and backup devices but also maintains high levels of security and efficiency using symmetric data encryption and authentication mechanisms.
## Security Strategy and Implementation
### AES Encryption for Sensor Data:
Secure data transmission is a cornerstone of the IoT system, especially when dealing with environmental data such as temperature and humidity. In this project, Advanced Encryption Standard (AES) is implemented to encrypt sensor data before sending it to the MQTT broker. AES is widely recognized for its high security, efficiency, and suitability for constrained devices like the ESP32, which contains specialized hardware for the cipher.
### Encryption Mode:
AES is implemented in Electronic Codebook (ECB) mode, a basic block cipher mode. While ECB is generally not recommended for encrypting large data streams because an equal plaintext block always maps to the same ciphertext allowing for patterns to emerge, it is suitable for small and uniform data blocks such as sensor readings in this system. 
### Padding Mechanism:
Data blocks often do not align perfectly with AES's fixed block size (128 bits or 16 bytes). To address this, padding as PKCS#7 proposes to fill the remaining space in the block. PKCS#7 ensures that even payloads that aren’t multiple of the block sizes can be encrypted while maintaining compatibility with the AES algorithm.
### Key Management:
A symmetric key, shared between the ESP32 and the MQTT broker, is used for encryption and decryption. This key is for now hard coded in the code running on the ESP32, however, it can be protected using memory regions which are not exposed to external entities during operation or could even make use of eFuse explained later in the report.

### Workflow:
+ Sensor data is first collected from the DHT11 sensor.
+ The data is serialized into a JSON format.
+ Before transmission, the serialized data is padded (if necessary) and encrypted using AES.
+ The encrypted payload is sent to the MQTT broker over a secure connection, further protected by mutual authentication.

### Authentication Mechanism
Authentication in the system is implemented to ensure secure communication between the devices and the MQTT broker. This is achieved using a unique symmetric key between the ESP32 microcontrollers and with a x.509 certificate and private key for the MQTT IoT Core broker.

### MQTT Authentication
The system implements authentication for MQTT communication through the use of client certificates and private keys. These certificates and keys are generated as part of the connection kit automatically provided by the AWS IoT Broker when a 'thing' (a representation of the physical device) is registered with the AWS IoT Broker. The certificates and private keys are subsequently downloaded and securely stored on each ESP32 microcontroller, where they are utilized during the connection process with the MQTT broker. The broker then validates the device's certificate against a trusted certificate authority, ensuring that only authorized devices are permitted to establish a connection. This certificate-based authentication significantly strengthens security by preventing unauthorized devices from spoofing the sensors or engaging in the system's data exchange.
In addition to certificate-based authentication, the data transmitted to the MQTT broker is encrypted, ensuring that even if the communication channel is intercepted, the data remains secure and unreadable to unauthorized entities. The combination of encryption and certificate-based authentication provides a robust security mechanism to safeguard the communication process.
This communication is used in place of the classical username and password authentication mechanism because it provides a higher level of security, eliminating the vulnerabilities and attacks associated with password-based authentication like brute force etc. By using certificates and private keys, the system ensures mutual authentication, where both the device and the broker validate each other's identity, making it more resistant to unauthorized access, man-in-the-middle attacks, and other security threats. Additionally, this method eliminates the need for password management, which can often lead to weak or compromised credentials, further enhancing the overall security of the system.

### Bluetooth Communication Authentication
In the Bluetooth-based failover mechanism, authentication is achieved by encrypting device status messages using a symmetric key with lightweight encryption algorithms such as the Tiny Encryption Algorithm (TEA) before transmission. These encrypted messages, which indicate the current operational state (e.g., active or inactive), can only be decrypted by devices possessing the correct symmetric key, ensuring that unauthorized devices cannot alter or interfere with the failover process.
The system relies on encrypted status reports, such as the esp_run and esp_stop signals, which are validated by the receiving device to determine the operational status. If the backup device fails to receive valid status messages from the primary device within 60 seconds, it assumes control of the system's operations and begins transmitting its own sensor data. This failover mechanism ensures that only authenticated devices are involved in the process, guaranteeing both seamless continuity and secure coordination.
Furthermore, when the backup device receives a valid active signal from the primary ESP32 microcontroller, the system automatically transitions back to normal operation. This is achieved by the backup device periodically checking the status of the primary device every 10 seconds.
Bluetooth Communication Authentication was not carried out by using AES-128 encryption algorithm because it operates on a total of 16 bytes whereas the maximum size of Bluetooth payload is 32 bits. This size in compatibility makes AES impractical and difficult to implement for Bluetooth communication.
### Decryption Process for MQTT messages
Our system integrates the decryption process with the AWS IoT Core as Broker for MQTT to automatically trigger an AWS Lambda function when encrypted data from ESP32 devices is received. This Lambda function retrieves the decryption symmetric key stored in another AWS service called Secrets Manager based upon IAM policies. These policies were integrated into the Lambda function at the time of configuration of Secret Manager and Lambda function. This is done to avoid hard-coded credentials, and storing keys securely by controlling the access is strictly using IAM roles to ensure only authorized functions can retrieve the keys. It should also be noted that this symmetric decryption key was manually placed in AWS Secret Manager by the development team at the time of initializing the Lambda function. The Lambda function decrypts the data using AES decryption key and automatically stores the decrypted data into AWS Timestream Database. This setup ensures secure key management, role-based access control (RBAC), and seamless real-time decryption along with storing and visualizing the real time traffic coming from IoT devices which in our case are ESP32 microcontrollers, aligning with best practices for secure IoT systems.

## Program Flow Diagram
![alt text](https://github.com/0x7a6b4c/Failover-and-Secure-Cloud-IoT-System-Architecture/blob/main/image/ProgramFlowDiagram.png)
